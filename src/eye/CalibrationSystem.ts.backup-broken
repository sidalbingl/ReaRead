/**
 * Advanced Calibration System
 *
 * Multi-point calibration (21-25 points) for high accuracy
 * Supports both explicit calibration and implicit improvement
 */

export interface CalibrationPoint {
  x: number;
  y: number;
  type: 'explicit' | 'implicit';
  confidence: number;
  timestamp: number;
}

export interface CalibrationData {
  points: CalibrationPoint[];
  accuracy?: number; // Average error in pixels
  timestamp: number;
  screenWidth: number;
  screenHeight: number;
}

export class CalibrationSystem {
  private calibrationPoints: CalibrationPoint[] = [];
  private storageKey = 'rearead_mediapipe_calibration';

  // Calibration grid configuration
  private gridConfig = {
    rows: 5,
    cols: 5,
    marginX: 0.1, // 10% margin from edges
    marginY: 0.1
  };

  /**
   * Generate calibration grid positions
   * Returns 25 points in a 5x5 grid
   */
  generateCalibrationGrid(): Array<{ x: number; y: number }> {
    const points: Array<{ x: number; y: number }> = [];
    const width = window.innerWidth;
    const height = window.innerHeight;

    const startX = width * this.gridConfig.marginX;
    const endX = width * (1 - this.gridConfig.marginX);
    const startY = height * this.gridConfig.marginY;
    const endY = height * (1 - this.gridConfig.marginY);

    const stepX = (endX - startX) / (this.gridConfig.cols - 1);
    const stepY = (endY - startY) / (this.gridConfig.rows - 1);

    for (let row = 0; row < this.gridConfig.rows; row++) {
      for (let col = 0; col < this.gridConfig.cols; col++) {
        points.push({
          x: startX + col * stepX,
          y: startY + row * stepY
        });
      }
    }

    return points;
  }

  /**
   * Show calibration UI and collect gaze data
   */
  async runExplicitCalibration(
    onGazeCapture: (point: { x: number; y: number }) => Promise<{ x: number; y: number }>
  ): Promise<CalibrationData> {
    return new Promise((resolve) => {
      const overlay = this.createCalibrationOverlay();
      document.body.appendChild(overlay);

      const points = this.generateCalibrationGrid();
      let currentIndex = 0;
      const calibrationData: CalibrationPoint[] = [];

      const showNextPoint = async () => {
        if (currentIndex >= points.length) {
          // Calibration complete
          overlay.remove();

          const data: CalibrationData = {
            points: calibrationData,
            timestamp: Date.now(),
            screenWidth: window.innerWidth,
            screenHeight: window.innerHeight
          };

          await this.saveCalibration(data);
          resolve(data);
          return;
        }

        const targetPoint = points[currentIndex];
        const dot = overlay.querySelector('.calibration-dot') as HTMLDivElement;

        // Position the calibration dot
        dot.style.left = `${targetPoint.x}px`;
        dot.style.top = `${targetPoint.y}px`;

        // Update progress
        const progress = overlay.querySelector('.calibration-progress') as HTMLDivElement;
        progress.textContent = `Calibration: ${currentIndex + 1} / ${points.length}`;

        // Wait for user to focus and capture gaze
        setTimeout(async () => {
          try {
            await onGazeCapture(targetPoint);

            calibrationData.push({
              x: targetPoint.x,
              y: targetPoint.y,
              type: 'explicit',
              confidence: 1.0,
              timestamp: Date.now()
            });

            currentIndex++;
            showNextPoint();
          } catch (error) {
            console.error('[Calibration] Gaze capture failed:', error);
            currentIndex++;
            showNextPoint();
          }
        }, 800); // Dwell time
      };

      showNextPoint();
    });
  }

  /**
   * Create calibration overlay UI
   */
  private createCalibrationOverlay(): HTMLDivElement {
    const overlay = document.createElement('div');
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      z-index: 99999999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: system-ui, sans-serif;
    `;

    overlay.innerHTML = `
      <style>
        @keyframes calibration-pulse {
          0%, 100% { transform: translate(-50%, -50%) scale(1); }
          50% { transform: translate(-50%, -50%) scale(1.3); }
        }
      </style>

      <div style="
        color: white;
        text-align: center;
        margin-bottom: 40px;
        max-width: 600px;
        padding: 0 20px;
      ">
        <h2 style="font-size: 32px; margin-bottom: 16px;">üëÅÔ∏è Eye Tracking Calibration</h2>
        <p style="font-size: 18px; opacity: 0.9; line-height: 1.6;">
          Look at each red dot and <strong>keep looking</strong> until it disappears.<br>
          This will take about <strong>20 seconds</strong>.
        </p>
        <div class="calibration-progress" style="
          margin-top: 16px;
          font-size: 14px;
          opacity: 0.7;
        ">Calibration: 0 / 25</div>
      </div>

      <div class="calibration-dot" style="
        position: fixed;
        width: 20px;
        height: 20px;
        background: #ef4444;
        border: 3px solid white;
        border-radius: 50%;
        animation: calibration-pulse 0.8s ease-in-out infinite;
        box-shadow: 0 0 30px rgba(239, 68, 68, 0.8);
        z-index: 999999999;
      "></div>
    `;

    return overlay;
  }

  /**
   * Add implicit calibration point (from user interaction)
   */
  addImplicitPoint(x: number, y: number, confidence: number = 0.7): void {
    this.calibrationPoints.push({
      x,
      y,
      type: 'implicit',
      confidence,
      timestamp: Date.now()
    });

    // Keep only recent 100 implicit points
    if (this.calibrationPoints.filter(p => p.type === 'implicit').length > 100) {
      const firstImplicitIndex = this.calibrationPoints.findIndex(p => p.type === 'implicit');
      this.calibrationPoints.splice(firstImplicitIndex, 1);
    }
  }

  /**
   * Save calibration data to storage
   */
  async saveCalibration(data: CalibrationData): Promise<void> {
    try {
      await chrome.storage.local.set({
        [this.storageKey]: JSON.stringify(data)
      });
      console.log('[Calibration] ‚úÖ Saved successfully');
    } catch (error) {
      console.error('[Calibration] Save failed:', error);
    }
  }

  /**
   * Load saved calibration data
   */
  async loadCalibration(): Promise<CalibrationData | null> {
    try {
      const result = await chrome.storage.local.get([this.storageKey]);

      if (result[this.storageKey]) {
        const data: CalibrationData = JSON.parse(result[this.storageKey]);

        // Check if calibration is still valid
        if (this.isCalibrationValid(data)) {
          this.calibrationPoints = data.points;
          console.log('[Calibration] ‚úÖ Loaded from storage');
          return data;
        } else {
          console.log('[Calibration] Stored data is expired or invalid');
        }
      }

      return null;
    } catch (error) {
      console.error('[Calibration] Load failed:', error);
      return null;
    }
  }

  /**
   * Check if calibration is still valid
   */
  private isCalibrationValid(data: CalibrationData): boolean {
    const now = Date.now();
    const age = now - data.timestamp;
    const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days

    if (age > maxAge) {
      console.log('[Calibration] Expired (>7 days)');
      return false;
    }

    if (data.screenWidth !== window.innerWidth || data.screenHeight !== window.innerHeight) {
      console.log('[Calibration] Screen size changed');
      return false;
    }

    if (data.points.length < 9) {
      console.log('[Calibration] Insufficient calibration points');
      return false;
    }

    return true;
  }

  /**
   * Calculate calibration offset from collected points
   */
  calculateCalibrationOffset(
    measuredPoints: Array<{ x: number; y: number }>
  ): { offsetX: number; offsetY: number; scaleX: number; scaleY: number } {
    if (this.calibrationPoints.length === 0 || measuredPoints.length === 0) {
      return { offsetX: 0, offsetY: 0, scaleX: 1, scaleY: 1 };
    }

    let totalOffsetX = 0;
    let totalOffsetY = 0;
    let count = Math.min(this.calibrationPoints.length, measuredPoints.length);

    for (let i = 0; i < count; i++) {
      totalOffsetX += this.calibrationPoints[i].x - measuredPoints[i].x;
      totalOffsetY += this.calibrationPoints[i].y - measuredPoints[i].y;
    }

    return {
      offsetX: totalOffsetX / count,
      offsetY: totalOffsetY / count,
      scaleX: 1.0, // Can be improved with regression
      scaleY: 1.0
    };
  }

  /**
   * Get all calibration points
   */
  getCalibrationPoints(): CalibrationPoint[] {
    return this.calibrationPoints;
  }

  /**
   * Clear all calibration data
   */
  async clearCalibration(): Promise<void> {
    this.calibrationPoints = [];
    await chrome.storage.local.remove([this.storageKey]);
    console.log('[Calibration] Cleared');
  }
}
